// @generated by protobuf-ts 2.8.3 with parameter long_type_string
// @generated from protobuf file "pb/summary/summary.proto" (package "testgrid.summary", syntax proto3)
// tslint:disable
//
// Summary info for TestGrid tests, dashboard tabs, and dashboards.
// Stored in GCS as "dashboard-<normalized dashboard name>".
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../google/protobuf/timestamp";
/**
 * Summary of a failing test.
 *
 * @generated from protobuf message testgrid.summary.FailingTestSummary
 */
export interface FailingTestSummary {
    /**
     * Display name of the test.
     *
     * @generated from protobuf field: string display_name = 1;
     */
    displayName: string;
    /**
     * Name of the test. E.g., the target for tests in Sponge.
     *
     * @generated from protobuf field: string test_name = 2;
     */
    testName: string;
    /**
     * First build ID at which the test failed.
     *
     * @generated from protobuf field: string fail_build_id = 3;
     */
    failBuildId: string;
    /**
     * Timestamp for the first cycle in which the test failed.
     *
     * @generated from protobuf field: double fail_timestamp = 4;
     */
    failTimestamp: number;
    /**
     * Last build ID at which the test passed.
     *
     * @generated from protobuf field: string pass_build_id = 5;
     */
    passBuildId: string;
    /**
     * Timestamp for the last cycle in which the test passed.
     *
     * @generated from protobuf field: double pass_timestamp = 6;
     */
    passTimestamp: number;
    /**
     * Number of times the test has failed.
     *
     * @generated from protobuf field: int32 fail_count = 7;
     */
    failCount: number;
    /**
     * Link to search for build changes.
     *
     * @generated from protobuf field: string build_link = 8;
     */
    buildLink: string;
    /**
     * Text for option to search for build changes.
     *
     * @generated from protobuf field: string build_link_text = 9;
     */
    buildLinkText: string;
    /**
     * Text to display for link to search for build changes.
     *
     * @generated from protobuf field: string build_url_text = 10;
     */
    buildUrlText: string;
    /**
     * Text for failure statuses associated with this test.
     *
     * @generated from protobuf field: string failure_message = 11;
     */
    failureMessage: string;
    /**
     * List of bug IDs for bugs associated with this test.
     *
     * @generated from protobuf field: repeated string linked_bugs = 12;
     */
    linkedBugs: string[];
    /**
     * A link to the first build in which the test failed.
     *
     * @generated from protobuf field: string fail_test_link = 13;
     */
    failTestLink: string;
    /**
     * A link to the latest build in which the test failed.
     *
     * @generated from protobuf field: string latest_fail_test_link = 17;
     */
    latestFailTestLink: string;
    /**
     * The test ID for the latest test failure. (Does not indicate the failure is
     * 'over', just the latest test failure we found.)
     *
     * @generated from protobuf field: string latest_fail_build_id = 14;
     */
    latestFailBuildId: string;
    /**
     * Maps (property name):(property value) for arbitrary alert properties.
     *
     * @generated from protobuf field: map<string, string> properties = 15;
     */
    properties: {
        [key: string]: string;
    };
    /**
     * A list of IDs for issue hotlists related to this failure.
     *
     * @generated from protobuf field: repeated string hotlist_ids = 16;
     */
    hotlistIds: string[];
    /**
     * Dynamic email list, route email alerts to these instead of the configured
     * defaults.
     *
     * @generated from protobuf field: repeated string email_addresses = 18;
     */
    emailAddresses: string[];
}
/**
 * Metrics about a specific test, i.e. passes, fails, total runs, etc.
 * Next ID: 12
 *
 * @generated from protobuf message testgrid.summary.TestInfo
 */
export interface TestInfo {
    /**
     * The display name of the test, typically what is shown for each row in
     * TestGrid
     *
     * @generated from protobuf field: string display_name = 1;
     */
    displayName: string;
    /**
     * The total number of test runs not including runs failed due to
     * infrastructure failures.
     *
     * @generated from protobuf field: int32 total_non_infra_runs = 2;
     */
    totalNonInfraRuns: number;
    /**
     * The number of passed test runs not including runs failed due to
     * infrastructure failures.
     *
     * @generated from protobuf field: int32 passed_non_infra_runs = 3;
     */
    passedNonInfraRuns: number;
    /**
     * The number of failed test runs not including runs failed due to
     * infrastructure failures.
     *
     * @generated from protobuf field: int32 failed_non_infra_runs = 4;
     */
    failedNonInfraRuns: number;
    /**
     * The number of failed test runs specifically due to infrastructure
     * failures.
     *
     * @generated from protobuf field: int32 failed_infra_runs = 5;
     */
    failedInfraRuns: number;
    /**
     * The total number of all runs, including failures due to infrastructure
     *
     * @generated from protobuf field: int32 total_runs_with_infra = 6;
     */
    totalRunsWithInfra: number;
    /**
     * Any other type of runs not included above.
     *
     * @generated from protobuf field: int32 other_runs = 7;
     */
    otherRuns: number;
    /**
     * The flakiness of the test, measured out of 100
     *
     * @generated from protobuf field: float flakiness = 8;
     */
    flakiness: number;
    /**
     * The flakiness of the test from previous intervals
     *
     * @generated from protobuf field: repeated float previous_flakiness = 10;
     */
    previousFlakiness: number[];
    /**
     * The change of flakiness based on the last interval's flakiness
     * e.g. if last interval the flakiness was 50, and now it's 75, the
     * trend is UP. A trend of NO_CHANGE means last week and this week were
     * exactly the same. The interval is set by each tab's config, with
     * a default of 7 days.
     *
     * @generated from protobuf field: testgrid.summary.TestInfo.Trend change_from_last_interval = 9;
     */
    changeFromLastInterval: TestInfo_Trend;
    /**
     * A map of infra failure name to the count of that failure for the interval.
     *
     * @generated from protobuf field: map<string, int32> infra_failures = 11;
     */
    infraFailures: {
        [key: string]: number;
    };
}
/**
 * @generated from protobuf enum testgrid.summary.TestInfo.Trend
 */
export enum TestInfo_Trend {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: NO_CHANGE = 1;
     */
    NO_CHANGE = 1,
    /**
     * @generated from protobuf enum value: UP = 2;
     */
    UP = 2,
    /**
     * @generated from protobuf enum value: DOWN = 3;
     */
    DOWN = 3
}
/**
 * Summary of the flakiness and overall healthiness of a dashboard tab
 *
 * @generated from protobuf message testgrid.summary.HealthinessInfo
 */
export interface HealthinessInfo {
    /**
     * The start of the time frame that the analysis was run for.
     * Represents the lower bound but does not guarantee that the earliest
     * test occurred at start
     *
     * @generated from protobuf field: google.protobuf.Timestamp start = 1;
     */
    start?: Timestamp;
    /**
     * The end of the time frame that the analysis was run for.
     * Same caveat as above but for upper bound.
     *
     * @generated from protobuf field: google.protobuf.Timestamp end = 2;
     */
    end?: Timestamp;
    /**
     * A list of test entries associated with this tab + timeframe.
     *
     * @generated from protobuf field: repeated testgrid.summary.TestInfo tests = 3;
     */
    tests: TestInfo[];
    /**
     * The flakiness out of 100 (think percentage but drop the sign)
     *
     * @generated from protobuf field: float average_flakiness = 4;
     */
    averageFlakiness: number;
    /**
     * The average flakiness for previous intervals
     *
     * @generated from protobuf field: repeated float previous_flakiness = 5;
     */
    previousFlakiness: number[];
}
/**
 * Information about alerts that have been sent
 *
 * @generated from protobuf message testgrid.summary.AlertingData
 */
export interface AlertingData {
    /**
     * Seconds since epoch at which an email was last sent
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_email_time = 1;
     */
    lastEmailTime?: Timestamp;
}
/**
 * Summary of a dashboard tab.
 *
 * @generated from protobuf message testgrid.summary.DashboardTabSummary
 */
export interface DashboardTabSummary {
    /**
     * The name of the dashboard.
     *
     * @generated from protobuf field: string dashboard_name = 1;
     */
    dashboardName: string;
    /**
     * The name of the dashboard tab.
     *
     * @generated from protobuf field: string dashboard_tab_name = 2;
     */
    dashboardTabName: string;
    /**
     * Any top-level alert on this dashboard tab.
     *
     * @generated from protobuf field: string alert = 3;
     */
    alert: string;
    /**
     * List of failing test summary information.
     *
     * @generated from protobuf field: repeated testgrid.summary.FailingTestSummary failing_test_summaries = 4;
     */
    failingTestSummaries: FailingTestSummary[];
    /**
     * Seconds since epoch at which the test group was last updated.
     *
     * @generated from protobuf field: double last_update_timestamp = 5;
     */
    lastUpdateTimestamp: number;
    /**
     * A summary of the status of this dashboard tab.
     *
     * @generated from protobuf field: string status = 6;
     */
    status: string;
    /**
     * The overall status for this dashboard tab.
     *
     * @generated from protobuf field: testgrid.summary.DashboardTabSummary.TabStatus overall_status = 7;
     */
    overallStatus: DashboardTabSummary_TabStatus;
    /**
     * The ID for the latest passing build.
     *
     * @generated from protobuf field: string latest_green = 8;
     */
    latestGreen: string;
    /**
     * Seconds since epoch at which tests last ran.
     *
     * @generated from protobuf field: double last_run_timestamp = 9;
     */
    lastRunTimestamp: number;
    /**
     * String indicating the URL for linking to a bug.
     *
     * @generated from protobuf field: string bug_url = 10;
     */
    bugUrl: string;
    /**
     * Metrics for the recent healthiness of a tab
     *
     * @generated from protobuf field: testgrid.summary.HealthinessInfo healthiness = 12;
     */
    healthiness?: HealthinessInfo;
    /**
     * All the issue IDs linked to this tab.
     *
     * @generated from protobuf field: repeated string linked_issues = 13;
     */
    linkedIssues: string[];
    /**
     * Metrics about alerts sent with respect to this summary
     * Maintained by alerter; does not need to be populated by summarizer
     *
     * @generated from protobuf field: testgrid.summary.AlertingData alerting_data = 14;
     */
    alertingData?: AlertingData;
    /**
     * DEPRECATED: now part of the TabStatus.
     *
     * @deprecated
     * @generated from protobuf field: bool acceptably_flaky = 15 [deprecated = true];
     */
    acceptablyFlaky: boolean;
    /**
     * Additional metrics provided for the dashboard tab
     *
     * @generated from protobuf field: testgrid.summary.DashboardTabSummaryMetrics summary_metrics = 16;
     */
    summaryMetrics?: DashboardTabSummaryMetrics;
}
/**
 * @generated from protobuf enum testgrid.summary.DashboardTabSummary.TabStatus
 */
export enum DashboardTabSummary_TabStatus {
    /**
     * @generated from protobuf enum value: NOT_SET = 0;
     */
    NOT_SET = 0,
    /**
     * @generated from protobuf enum value: UNKNOWN = 1;
     */
    UNKNOWN = 1,
    /**
     * @generated from protobuf enum value: PASS = 2;
     */
    PASS = 2,
    /**
     * @generated from protobuf enum value: FAIL = 3;
     */
    FAIL = 3,
    /**
     * @generated from protobuf enum value: FLAKY = 4;
     */
    FLAKY = 4,
    /**
     * @generated from protobuf enum value: STALE = 5;
     */
    STALE = 5,
    /**
     * @generated from protobuf enum value: BROKEN = 6;
     */
    BROKEN = 6,
    /**
     * @generated from protobuf enum value: PENDING = 7;
     */
    PENDING = 7,
    /**
     * @generated from protobuf enum value: ACCEPTABLE = 8;
     */
    ACCEPTABLE = 8
}
/**
 * Most recent summary metrics for the tab calculated over columns (not individual tests)
 *
 * @generated from protobuf message testgrid.summary.DashboardTabSummaryMetrics
 */
export interface DashboardTabSummaryMetrics {
    /**
     * Number of total columns analyzed by summarizer
     *
     * @generated from protobuf field: int32 completed_columns = 1;
     */
    completedColumns: number;
    /**
     * Number of columns with all tests passing
     *
     * @generated from protobuf field: int32 passing_columns = 2;
     */
    passingColumns: number;
    /**
     * Number of ignored columns
     *
     * @generated from protobuf field: int32 ignored_columns = 3;
     */
    ignoredColumns: number;
}
/**
 * Summary state of a dashboard.
 *
 * @generated from protobuf message testgrid.summary.DashboardSummary
 */
export interface DashboardSummary {
    /**
     * Summary of a dashboard tab; see config.proto.
     *
     * @generated from protobuf field: repeated testgrid.summary.DashboardTabSummary tab_summaries = 1;
     */
    tabSummaries: DashboardTabSummary[];
}
// @generated message type with reflection information, may provide speed optimized methods
class FailingTestSummary$Type extends MessageType<FailingTestSummary> {
    constructor() {
        super("testgrid.summary.FailingTestSummary", [
            { no: 1, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "test_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "fail_build_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "fail_timestamp", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "pass_build_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "pass_timestamp", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "fail_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "build_link", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "build_link_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "build_url_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "failure_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "linked_bugs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "fail_test_link", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "latest_fail_test_link", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "latest_fail_build_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "properties", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 16, name: "hotlist_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "email_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FailingTestSummary>): FailingTestSummary {
        const message = { displayName: "", testName: "", failBuildId: "", failTimestamp: 0, passBuildId: "", passTimestamp: 0, failCount: 0, buildLink: "", buildLinkText: "", buildUrlText: "", failureMessage: "", linkedBugs: [], failTestLink: "", latestFailTestLink: "", latestFailBuildId: "", properties: {}, hotlistIds: [], emailAddresses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FailingTestSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FailingTestSummary): FailingTestSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string display_name */ 1:
                    message.displayName = reader.string();
                    break;
                case /* string test_name */ 2:
                    message.testName = reader.string();
                    break;
                case /* string fail_build_id */ 3:
                    message.failBuildId = reader.string();
                    break;
                case /* double fail_timestamp */ 4:
                    message.failTimestamp = reader.double();
                    break;
                case /* string pass_build_id */ 5:
                    message.passBuildId = reader.string();
                    break;
                case /* double pass_timestamp */ 6:
                    message.passTimestamp = reader.double();
                    break;
                case /* int32 fail_count */ 7:
                    message.failCount = reader.int32();
                    break;
                case /* string build_link */ 8:
                    message.buildLink = reader.string();
                    break;
                case /* string build_link_text */ 9:
                    message.buildLinkText = reader.string();
                    break;
                case /* string build_url_text */ 10:
                    message.buildUrlText = reader.string();
                    break;
                case /* string failure_message */ 11:
                    message.failureMessage = reader.string();
                    break;
                case /* repeated string linked_bugs */ 12:
                    message.linkedBugs.push(reader.string());
                    break;
                case /* string fail_test_link */ 13:
                    message.failTestLink = reader.string();
                    break;
                case /* string latest_fail_test_link */ 17:
                    message.latestFailTestLink = reader.string();
                    break;
                case /* string latest_fail_build_id */ 14:
                    message.latestFailBuildId = reader.string();
                    break;
                case /* map<string, string> properties */ 15:
                    this.binaryReadMap15(message.properties, reader, options);
                    break;
                case /* repeated string hotlist_ids */ 16:
                    message.hotlistIds.push(reader.string());
                    break;
                case /* repeated string email_addresses */ 18:
                    message.emailAddresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap15(map: FailingTestSummary["properties"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof FailingTestSummary["properties"] | undefined, val: FailingTestSummary["properties"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field testgrid.summary.FailingTestSummary.properties");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: FailingTestSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string display_name = 1; */
        if (message.displayName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.displayName);
        /* string test_name = 2; */
        if (message.testName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.testName);
        /* string fail_build_id = 3; */
        if (message.failBuildId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.failBuildId);
        /* double fail_timestamp = 4; */
        if (message.failTimestamp !== 0)
            writer.tag(4, WireType.Bit64).double(message.failTimestamp);
        /* string pass_build_id = 5; */
        if (message.passBuildId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.passBuildId);
        /* double pass_timestamp = 6; */
        if (message.passTimestamp !== 0)
            writer.tag(6, WireType.Bit64).double(message.passTimestamp);
        /* int32 fail_count = 7; */
        if (message.failCount !== 0)
            writer.tag(7, WireType.Varint).int32(message.failCount);
        /* string build_link = 8; */
        if (message.buildLink !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.buildLink);
        /* string build_link_text = 9; */
        if (message.buildLinkText !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.buildLinkText);
        /* string build_url_text = 10; */
        if (message.buildUrlText !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.buildUrlText);
        /* string failure_message = 11; */
        if (message.failureMessage !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.failureMessage);
        /* repeated string linked_bugs = 12; */
        for (let i = 0; i < message.linkedBugs.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.linkedBugs[i]);
        /* string fail_test_link = 13; */
        if (message.failTestLink !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.failTestLink);
        /* string latest_fail_test_link = 17; */
        if (message.latestFailTestLink !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.latestFailTestLink);
        /* string latest_fail_build_id = 14; */
        if (message.latestFailBuildId !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.latestFailBuildId);
        /* map<string, string> properties = 15; */
        for (let k of Object.keys(message.properties))
            writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.properties[k]).join();
        /* repeated string hotlist_ids = 16; */
        for (let i = 0; i < message.hotlistIds.length; i++)
            writer.tag(16, WireType.LengthDelimited).string(message.hotlistIds[i]);
        /* repeated string email_addresses = 18; */
        for (let i = 0; i < message.emailAddresses.length; i++)
            writer.tag(18, WireType.LengthDelimited).string(message.emailAddresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message testgrid.summary.FailingTestSummary
 */
export const FailingTestSummary = new FailingTestSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestInfo$Type extends MessageType<TestInfo> {
    constructor() {
        super("testgrid.summary.TestInfo", [
            { no: 1, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "total_non_infra_runs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "passed_non_infra_runs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "failed_non_infra_runs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "failed_infra_runs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "total_runs_with_infra", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "other_runs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "flakiness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "previous_flakiness", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "change_from_last_interval", kind: "enum", T: () => ["testgrid.summary.TestInfo.Trend", TestInfo_Trend] },
            { no: 11, name: "infra_failures", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
    create(value?: PartialMessage<TestInfo>): TestInfo {
        const message = { displayName: "", totalNonInfraRuns: 0, passedNonInfraRuns: 0, failedNonInfraRuns: 0, failedInfraRuns: 0, totalRunsWithInfra: 0, otherRuns: 0, flakiness: 0, previousFlakiness: [], changeFromLastInterval: 0, infraFailures: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TestInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestInfo): TestInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string display_name */ 1:
                    message.displayName = reader.string();
                    break;
                case /* int32 total_non_infra_runs */ 2:
                    message.totalNonInfraRuns = reader.int32();
                    break;
                case /* int32 passed_non_infra_runs */ 3:
                    message.passedNonInfraRuns = reader.int32();
                    break;
                case /* int32 failed_non_infra_runs */ 4:
                    message.failedNonInfraRuns = reader.int32();
                    break;
                case /* int32 failed_infra_runs */ 5:
                    message.failedInfraRuns = reader.int32();
                    break;
                case /* int32 total_runs_with_infra */ 6:
                    message.totalRunsWithInfra = reader.int32();
                    break;
                case /* int32 other_runs */ 7:
                    message.otherRuns = reader.int32();
                    break;
                case /* float flakiness */ 8:
                    message.flakiness = reader.float();
                    break;
                case /* repeated float previous_flakiness */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.previousFlakiness.push(reader.float());
                    else
                        message.previousFlakiness.push(reader.float());
                    break;
                case /* testgrid.summary.TestInfo.Trend change_from_last_interval */ 9:
                    message.changeFromLastInterval = reader.int32();
                    break;
                case /* map<string, int32> infra_failures */ 11:
                    this.binaryReadMap11(message.infraFailures, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap11(map: TestInfo["infraFailures"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TestInfo["infraFailures"] | undefined, val: TestInfo["infraFailures"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field testgrid.summary.TestInfo.infra_failures");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: TestInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string display_name = 1; */
        if (message.displayName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.displayName);
        /* int32 total_non_infra_runs = 2; */
        if (message.totalNonInfraRuns !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalNonInfraRuns);
        /* int32 passed_non_infra_runs = 3; */
        if (message.passedNonInfraRuns !== 0)
            writer.tag(3, WireType.Varint).int32(message.passedNonInfraRuns);
        /* int32 failed_non_infra_runs = 4; */
        if (message.failedNonInfraRuns !== 0)
            writer.tag(4, WireType.Varint).int32(message.failedNonInfraRuns);
        /* int32 failed_infra_runs = 5; */
        if (message.failedInfraRuns !== 0)
            writer.tag(5, WireType.Varint).int32(message.failedInfraRuns);
        /* int32 total_runs_with_infra = 6; */
        if (message.totalRunsWithInfra !== 0)
            writer.tag(6, WireType.Varint).int32(message.totalRunsWithInfra);
        /* int32 other_runs = 7; */
        if (message.otherRuns !== 0)
            writer.tag(7, WireType.Varint).int32(message.otherRuns);
        /* float flakiness = 8; */
        if (message.flakiness !== 0)
            writer.tag(8, WireType.Bit32).float(message.flakiness);
        /* repeated float previous_flakiness = 10; */
        if (message.previousFlakiness.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.previousFlakiness.length; i++)
                writer.float(message.previousFlakiness[i]);
            writer.join();
        }
        /* testgrid.summary.TestInfo.Trend change_from_last_interval = 9; */
        if (message.changeFromLastInterval !== 0)
            writer.tag(9, WireType.Varint).int32(message.changeFromLastInterval);
        /* map<string, int32> infra_failures = 11; */
        for (let k of Object.keys(message.infraFailures))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.infraFailures[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message testgrid.summary.TestInfo
 */
export const TestInfo = new TestInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthinessInfo$Type extends MessageType<HealthinessInfo> {
    constructor() {
        super("testgrid.summary.HealthinessInfo", [
            { no: 1, name: "start", kind: "message", T: () => Timestamp },
            { no: 2, name: "end", kind: "message", T: () => Timestamp },
            { no: 3, name: "tests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TestInfo },
            { no: 4, name: "average_flakiness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "previous_flakiness", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<HealthinessInfo>): HealthinessInfo {
        const message = { tests: [], averageFlakiness: 0, previousFlakiness: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HealthinessInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthinessInfo): HealthinessInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp start */ 1:
                    message.start = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* google.protobuf.Timestamp end */ 2:
                    message.end = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.end);
                    break;
                case /* repeated testgrid.summary.TestInfo tests */ 3:
                    message.tests.push(TestInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* float average_flakiness */ 4:
                    message.averageFlakiness = reader.float();
                    break;
                case /* repeated float previous_flakiness */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.previousFlakiness.push(reader.float());
                    else
                        message.previousFlakiness.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthinessInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp start = 1; */
        if (message.start)
            Timestamp.internalBinaryWrite(message.start, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end = 2; */
        if (message.end)
            Timestamp.internalBinaryWrite(message.end, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated testgrid.summary.TestInfo tests = 3; */
        for (let i = 0; i < message.tests.length; i++)
            TestInfo.internalBinaryWrite(message.tests[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* float average_flakiness = 4; */
        if (message.averageFlakiness !== 0)
            writer.tag(4, WireType.Bit32).float(message.averageFlakiness);
        /* repeated float previous_flakiness = 5; */
        if (message.previousFlakiness.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.previousFlakiness.length; i++)
                writer.float(message.previousFlakiness[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message testgrid.summary.HealthinessInfo
 */
export const HealthinessInfo = new HealthinessInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AlertingData$Type extends MessageType<AlertingData> {
    constructor() {
        super("testgrid.summary.AlertingData", [
            { no: 1, name: "last_email_time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<AlertingData>): AlertingData {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AlertingData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AlertingData): AlertingData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp last_email_time */ 1:
                    message.lastEmailTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastEmailTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AlertingData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp last_email_time = 1; */
        if (message.lastEmailTime)
            Timestamp.internalBinaryWrite(message.lastEmailTime, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message testgrid.summary.AlertingData
 */
export const AlertingData = new AlertingData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DashboardTabSummary$Type extends MessageType<DashboardTabSummary> {
    constructor() {
        super("testgrid.summary.DashboardTabSummary", [
            { no: 1, name: "dashboard_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dashboard_tab_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "alert", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "failing_test_summaries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FailingTestSummary },
            { no: 5, name: "last_update_timestamp", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "overall_status", kind: "enum", T: () => ["testgrid.summary.DashboardTabSummary.TabStatus", DashboardTabSummary_TabStatus] },
            { no: 8, name: "latest_green", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "last_run_timestamp", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "bug_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "healthiness", kind: "message", T: () => HealthinessInfo },
            { no: 13, name: "linked_issues", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "alerting_data", kind: "message", T: () => AlertingData },
            { no: 15, name: "acceptably_flaky", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "summary_metrics", kind: "message", T: () => DashboardTabSummaryMetrics }
        ]);
    }
    create(value?: PartialMessage<DashboardTabSummary>): DashboardTabSummary {
        const message = { dashboardName: "", dashboardTabName: "", alert: "", failingTestSummaries: [], lastUpdateTimestamp: 0, status: "", overallStatus: 0, latestGreen: "", lastRunTimestamp: 0, bugUrl: "", linkedIssues: [], acceptablyFlaky: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DashboardTabSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DashboardTabSummary): DashboardTabSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string dashboard_name */ 1:
                    message.dashboardName = reader.string();
                    break;
                case /* string dashboard_tab_name */ 2:
                    message.dashboardTabName = reader.string();
                    break;
                case /* string alert */ 3:
                    message.alert = reader.string();
                    break;
                case /* repeated testgrid.summary.FailingTestSummary failing_test_summaries */ 4:
                    message.failingTestSummaries.push(FailingTestSummary.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* double last_update_timestamp */ 5:
                    message.lastUpdateTimestamp = reader.double();
                    break;
                case /* string status */ 6:
                    message.status = reader.string();
                    break;
                case /* testgrid.summary.DashboardTabSummary.TabStatus overall_status */ 7:
                    message.overallStatus = reader.int32();
                    break;
                case /* string latest_green */ 8:
                    message.latestGreen = reader.string();
                    break;
                case /* double last_run_timestamp */ 9:
                    message.lastRunTimestamp = reader.double();
                    break;
                case /* string bug_url */ 10:
                    message.bugUrl = reader.string();
                    break;
                case /* testgrid.summary.HealthinessInfo healthiness */ 12:
                    message.healthiness = HealthinessInfo.internalBinaryRead(reader, reader.uint32(), options, message.healthiness);
                    break;
                case /* repeated string linked_issues */ 13:
                    message.linkedIssues.push(reader.string());
                    break;
                case /* testgrid.summary.AlertingData alerting_data */ 14:
                    message.alertingData = AlertingData.internalBinaryRead(reader, reader.uint32(), options, message.alertingData);
                    break;
                case /* bool acceptably_flaky = 15 [deprecated = true];*/ 15:
                    message.acceptablyFlaky = reader.bool();
                    break;
                case /* testgrid.summary.DashboardTabSummaryMetrics summary_metrics */ 16:
                    message.summaryMetrics = DashboardTabSummaryMetrics.internalBinaryRead(reader, reader.uint32(), options, message.summaryMetrics);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DashboardTabSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string dashboard_name = 1; */
        if (message.dashboardName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dashboardName);
        /* string dashboard_tab_name = 2; */
        if (message.dashboardTabName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dashboardTabName);
        /* string alert = 3; */
        if (message.alert !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.alert);
        /* repeated testgrid.summary.FailingTestSummary failing_test_summaries = 4; */
        for (let i = 0; i < message.failingTestSummaries.length; i++)
            FailingTestSummary.internalBinaryWrite(message.failingTestSummaries[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* double last_update_timestamp = 5; */
        if (message.lastUpdateTimestamp !== 0)
            writer.tag(5, WireType.Bit64).double(message.lastUpdateTimestamp);
        /* string status = 6; */
        if (message.status !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.status);
        /* testgrid.summary.DashboardTabSummary.TabStatus overall_status = 7; */
        if (message.overallStatus !== 0)
            writer.tag(7, WireType.Varint).int32(message.overallStatus);
        /* string latest_green = 8; */
        if (message.latestGreen !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.latestGreen);
        /* double last_run_timestamp = 9; */
        if (message.lastRunTimestamp !== 0)
            writer.tag(9, WireType.Bit64).double(message.lastRunTimestamp);
        /* string bug_url = 10; */
        if (message.bugUrl !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.bugUrl);
        /* testgrid.summary.HealthinessInfo healthiness = 12; */
        if (message.healthiness)
            HealthinessInfo.internalBinaryWrite(message.healthiness, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated string linked_issues = 13; */
        for (let i = 0; i < message.linkedIssues.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.linkedIssues[i]);
        /* testgrid.summary.AlertingData alerting_data = 14; */
        if (message.alertingData)
            AlertingData.internalBinaryWrite(message.alertingData, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* bool acceptably_flaky = 15 [deprecated = true]; */
        if (message.acceptablyFlaky !== false)
            writer.tag(15, WireType.Varint).bool(message.acceptablyFlaky);
        /* testgrid.summary.DashboardTabSummaryMetrics summary_metrics = 16; */
        if (message.summaryMetrics)
            DashboardTabSummaryMetrics.internalBinaryWrite(message.summaryMetrics, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message testgrid.summary.DashboardTabSummary
 */
export const DashboardTabSummary = new DashboardTabSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DashboardTabSummaryMetrics$Type extends MessageType<DashboardTabSummaryMetrics> {
    constructor() {
        super("testgrid.summary.DashboardTabSummaryMetrics", [
            { no: 1, name: "completed_columns", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "passing_columns", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "ignored_columns", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DashboardTabSummaryMetrics>): DashboardTabSummaryMetrics {
        const message = { completedColumns: 0, passingColumns: 0, ignoredColumns: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DashboardTabSummaryMetrics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DashboardTabSummaryMetrics): DashboardTabSummaryMetrics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 completed_columns */ 1:
                    message.completedColumns = reader.int32();
                    break;
                case /* int32 passing_columns */ 2:
                    message.passingColumns = reader.int32();
                    break;
                case /* int32 ignored_columns */ 3:
                    message.ignoredColumns = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DashboardTabSummaryMetrics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 completed_columns = 1; */
        if (message.completedColumns !== 0)
            writer.tag(1, WireType.Varint).int32(message.completedColumns);
        /* int32 passing_columns = 2; */
        if (message.passingColumns !== 0)
            writer.tag(2, WireType.Varint).int32(message.passingColumns);
        /* int32 ignored_columns = 3; */
        if (message.ignoredColumns !== 0)
            writer.tag(3, WireType.Varint).int32(message.ignoredColumns);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message testgrid.summary.DashboardTabSummaryMetrics
 */
export const DashboardTabSummaryMetrics = new DashboardTabSummaryMetrics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DashboardSummary$Type extends MessageType<DashboardSummary> {
    constructor() {
        super("testgrid.summary.DashboardSummary", [
            { no: 1, name: "tab_summaries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DashboardTabSummary }
        ]);
    }
    create(value?: PartialMessage<DashboardSummary>): DashboardSummary {
        const message = { tabSummaries: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DashboardSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DashboardSummary): DashboardSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated testgrid.summary.DashboardTabSummary tab_summaries */ 1:
                    message.tabSummaries.push(DashboardTabSummary.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DashboardSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated testgrid.summary.DashboardTabSummary tab_summaries = 1; */
        for (let i = 0; i < message.tabSummaries.length; i++)
            DashboardTabSummary.internalBinaryWrite(message.tabSummaries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message testgrid.summary.DashboardSummary
 */
export const DashboardSummary = new DashboardSummary$Type();
